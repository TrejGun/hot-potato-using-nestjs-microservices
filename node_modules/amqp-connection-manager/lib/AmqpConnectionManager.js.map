{"version":3,"sources":["../src/AmqpConnectionManager.js"],"names":["HEARTBEAT_IN_SECONDS","neverThrows","err","setImmediate","Error","message","stack","AmqpConnectionManager","EventEmitter","constructor","urls","options","findServers","_channels","_currentUrl","connectionOptions","heartbeatIntervalInSeconds","reconnectTimeInSeconds","setMaxListeners","_findServers","Promise","resolve","_connect","createChannel","channel","ChannelWrapper","push","once","filter","c","close","_closed","all","map","catch","then","_currentConnection","removeAllListeners","isConnected","_connecting","_urls","length","pb","callFn","Array","isArray","url","urlString","amqpUrl","Object","assign","heartbeat","urlUtils","parse","search","format","amqp","connect","connection","on","reason","emit"],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport amqp from 'amqplib';\nimport urlUtils from 'url';\n\nimport ChannelWrapper from './ChannelWrapper';\nimport { wait } from './helpers';\nimport pb from 'promise-breaker';\n\n// Default heartbeat time.\nconst HEARTBEAT_IN_SECONDS = 5;\n\n/* istanbul ignore next */\nfunction neverThrows() {\n    return err =>\n        setImmediate(() => {\n            throw new Error(`AmqpConnectionManager - should never get here: ${err.message}\\n` +\n                err.stack);\n        });\n}\n\n//\n// Events:\n// * `connect({connection, url})` - Emitted whenever we connect to a broker.\n// * `disconnect({err})` - Emitted whenever we disconnect from a broker.\n//\nexport default class AmqpConnectionManager extends EventEmitter {\n    /**\n     *  Create a new AmqplibConnectionManager.\n     *\n     * @param {(string|Object)[]} urls - An array of brokers to connect to.\n     *   Takes url strings or objects {url: string, connectionOptions?: object}\n     *   If present, a broker's [connectionOptions] will be used instead\n     *   of [options.connectionOptions] when passed to the amqplib connect method.\n     *   AmqplibConnectionManager will round-robin between them whenever it\n     *   needs to create a new connection.\n     * @param {Object} [options={}] -\n     * @param {number} [options.heartbeatIntervalInSeconds=5] - The interval,\n     *   in seconds, to send heartbeats.\n     * @param {number} [options.reconnectTimeInSeconds] - The time to wait\n     *   before trying to reconnect.  If not specified, defaults to\n     *   `heartbeatIntervalInSeconds`.\n     * @param {Object} [options.connectionOptions] - Passed to the amqplib\n     *   connect method.\n     * @param {function} [options.findServers] - A `fn(callback)` or a `fn()`\n     *   which returns a Promise.  This should resolve to one or more servers\n     *   to connect to, either a single URL or an array of URLs.  This is handy\n     *   when you're using a service discovery mechanism such as Consul or etcd.\n     *   Note that if this is supplied, then `urls` is ignored.\n     */\n    constructor(urls, options = {}) {\n        super();\n        if(!urls && !options.findServers) {\n            throw new Error(\"Must supply either `urls` or `findServers`\");\n        }\n        this._channels = [];\n\n        this._currentUrl = 0;\n        this.connectionOptions = options.connectionOptions;\n\n        this.heartbeatIntervalInSeconds = options.heartbeatIntervalInSeconds || HEARTBEAT_IN_SECONDS;\n        this.reconnectTimeInSeconds = options.reconnectTimeInSeconds || this.heartbeatIntervalInSeconds;\n\n        // There will be one listener per channel, and there could be a lot of channels, so disable warnings from node.\n        this.setMaxListeners(0);\n\n        this._findServers = options.findServers || (() => Promise.resolve(urls));\n\n        this._connect();\n    }\n\n    // `options` here are any options that can be passed to ChannelWrapper.\n    createChannel(options = {}) {\n        const channel = new ChannelWrapper(this, options);\n        this._channels.push(channel);\n        channel.once('close', () => {\n            this._channels = this._channels.filter(c => c !== channel);\n        });\n        return channel;\n    }\n\n    close() {\n        if(this._closed) { return Promise.resolve(); }\n        this._closed = true;\n\n        return Promise.all(this._channels.map(channel => channel.close()))\n            .catch(function() {\n                // Ignore errors closing channels.\n            })\n            .then(() => {\n                this._channels = [];\n                if(this._currentConnection) {\n                    this._currentConnection.removeAllListeners('close');\n                    this._currentConnection.close();\n                }\n                this._currentConnection = null;\n            });\n    }\n\n    isConnected() {\n        return !!this._currentConnection;\n    }\n\n    _connect() {\n        if(this._closed || this._connecting || this.isConnected()) {\n            return Promise.resolve();\n        }\n\n        this._connecting = true;\n\n        return Promise.resolve()\n        .then(() => {\n            if(!this._urls || (this._currentUrl >= this._urls.length)) {\n                this._currentUrl = 0;\n                return pb.callFn(this._findServers, 0, null);\n            } else {\n                return this._urls;\n            }\n        })\n        .then(urls => {\n            if(urls && !Array.isArray(urls)) { urls = [urls]; }\n            this._urls = urls;\n\n            if(!urls || (urls.length === 0)) {\n                throw new Error('amqp-connection-manager: No servers found');\n            }\n\n            // Round robin between brokers\n            const url = urls[this._currentUrl];\n            this._currentUrl++;\n\n            // url can be a string or object {url: string, connectionOptions?: object}\n            const urlString = url.url || url;\n            const connectionOptions = url.connectionOptions || this.connectionOptions;\n\n            let amqpUrl = null;\n\n            if(typeof urlString === \"object\") {\n                amqpUrl = Object.assign({}, url);\n                if(!amqpUrl.heartbeat) {\n                    amqpUrl.heartbeat = this.heartbeatIntervalInSeconds;\n                }\n            }else {\n                amqpUrl = urlUtils.parse(urlString);\n                if(amqpUrl.search) {\n                    amqpUrl.search += `&heartbeat=${this.heartbeatIntervalInSeconds}`;\n                } else {\n                    amqpUrl.search = `?heartbeat=${this.heartbeatIntervalInSeconds}`;\n                }\n                amqpUrl = urlUtils.format(amqpUrl);\n            }\n\n\n            return amqp.connect(amqpUrl, connectionOptions)\n            .then(connection => {\n                this._currentConnection = connection;\n\n                //emit 'blocked' when RabbitMQ server decides to block the connection (resources running low)\n                connection.on('blocked', reason => this.emit('blocked', { reason }));\n\n                connection.on('unblocked', () => this.emit('unblocked'));\n\n                connection.on('error', (/* err */) => {\n                    // if this event was emitted, then the connection was already closed,\n                    // so no need to call #close here\n                    // also, 'close' is emitted after 'error',\n                    // so no need for work already done in 'close' handler\n                });\n\n                // Reconnect if the connection closes\n                connection.on('close', err => {\n                    this._currentConnection = null;\n                    this.emit('disconnect', { err });\n\n                    wait(this.reconnectTimeInSeconds * 1000)\n                    .then(() => this._connect())\n                    // `_connect()` should never throw.\n                    .catch(neverThrows);\n                });\n\n                this._connecting = false;\n                this.emit('connect', { connection, url: urlString });\n\n                return null;\n            });\n        })\n        .catch(err => {\n            this.emit('disconnect', { err });\n\n            // Connection failed...\n            this._currentConnection = null;\n\n            // TODO: Probably want to try right away here, especially if there are multiple brokers to try...\n            return wait(this.reconnectTimeInSeconds * 1000)\n            .then(() => {\n                this._connecting = false;\n                return this._connect();\n            });\n        });\n    }\n}\n"],"file":"AmqpConnectionManager.js"}