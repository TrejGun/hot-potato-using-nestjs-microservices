{"version":3,"sources":["../src/ChannelWrapper.js"],"names":["ChannelWrapper","EventEmitter","addSetup","setup","done","pb","addCallback","_settingUp","Promise","resolve","then","_setups","push","_channel","call","undefined","removeSetup","teardown","filter","s","waitForConnect","once","publish","exchange","routingKey","content","options","reject","_messages","type","_startWorker","sendToQueue","queue","constructor","connectionManager","_onConnect","bind","_onDisconnect","_connectionManager","name","context","_json","json","_unconfirmedMessages","_working","_workerNumber","isConnected","connection","_currentConnection","on","_connection","createConfirmChannel","channel","_onChannelClose","all","map","setupFn","catch","err","emit","length","shift","queueLength","close","forEach","message","Error","removeListener","answer","_shouldPublish","_publishQueuedMessages","workerNumber","encodedMessage","Buffer","from","JSON","stringify","sendPromise","result","setImmediate","unshift","ack","apply","arguments","ackAll","nack","nackAll","purgeQueue","checkQueue","assertQueue","bindQueue","assertExchange"],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport pb from 'promise-breaker';\n\n/**\n *  Calls to `publish()` or `sendToQueue()` work just like in amqplib, but messages are queued internally and\n * are guaranteed to be delivered.  If the underlying connection drops, ChannelWrapper will wait for a new\n * connection and continue.\n *\n * Events:\n * * `connect` - emitted every time this channel connects or reconnects.\n * * `error(err, {name})` - emitted if an error occurs setting up the channel.\n * * `drop({message, err})` - called when a JSON message was dropped because it could not be encoded.\n * * `close` - emitted when this channel closes via a call to `close()`\n *\n */\nexport default class ChannelWrapper extends EventEmitter {\n    /**\n     *  Adds a new 'setup handler'.\n     *\n     * `setup(channel, [cb])` is a function to call when a new underlying channel is created - handy for asserting\n     * exchanges and queues exists, and whatnot.  The `channel` object here is a ConfigChannel from amqplib.\n     * The `setup` function should return a Promise (or optionally take a callback) - no messages will be sent until\n     * this Promise resolves.\n     *\n     * If there is a connection, `setup()` will be run immediately, and the addSetup Promise/callback won't resolve\n     * until `setup` is complete.  Note that in this case, if the setup throws an error, no 'error' event will\n     * be emitted, since you can just handle the error here (although the `setup` will still be added for future\n     * reconnects, even if it throws an error.)\n     *\n     * Setup functions should, ideally, not throw errors, but if they do then the ChannelWrapper will emit an 'error'\n     * event.\n     *\n     * @param {function} setup - setup function.\n     * @param {function} [done] - callback.\n     * @returns {void | Promise} - Resolves when complete.\n     */\n    addSetup(setup, done=null) {\n        return pb.addCallback(done,\n            (this._settingUp || Promise.resolve())\n            .then(() => {\n                this._setups.push(setup);\n                if(this._channel) {\n                    return pb.call(setup, this, this._channel);\n                } else {\n                    return undefined;\n                }\n            })\n        );\n    }\n\n    /**\n     * Remove a setup function added with `addSetup`.  If there is currently a\n     * connection, `teardown(channel, [cb])` will be run immediately, and the\n     * returned Promise will not resolve until it completes.\n     *\n     * @param {function} setup - the setup function to remove.\n     * @param {function} [teardown] - `function(channel, [cb])` to run to tear\n     *   down the channel.\n     * @param {function} [done] - Optional callback.\n     * @returns {void | Promise} - Resolves when complete.\n     */\n    removeSetup(setup, teardown=null, done=null) {\n        return pb.addCallback(done, () => {\n            this._setups = this._setups.filter(s => s !== setup);\n\n            return (this._settingUp || Promise.resolve())\n            .then(() => this._channel\n                ? pb.call(teardown, this, this._channel)\n                : undefined\n            );\n        });\n    }\n\n    /**\n     * Returns a Promise which resolves when this channel next connects.\n     * (Mainly here for unit testing...)\n     *\n     * @param {function} [done] - Optional callback.\n     * @returns {void | Promise} - Resolves when connected.\n     */\n    waitForConnect(done=null) {\n        return pb.addCallback(done,\n            (this._channel && !this._settingUp)\n                ? Promise.resolve()\n                : new Promise(resolve => this.once('connect', resolve))\n        );\n    }\n\n    /*\n     * Publish a message to the channel.\n     *\n     * This works just like amqplib's `publish()`, except if the channel is not\n     * connected, this will wait until the channel is connected.  Returns a\n     * Promise which will only resolve when the message has been succesfully sent.\n     * The returned promise will be rejected if `close()` is called on this\n     * channel before it can be sent, if `options.json` is set and the message\n     * can't be encoded, or if the broker rejects the message for some reason.\n     *\n     */\n    publish(exchange, routingKey, content, options, done=null) {\n        return pb.addCallback(done, new Promise((resolve, reject) => {\n            this._messages.push({\n                type: 'publish',\n                exchange,\n                routingKey,\n                content,\n                options,\n                resolve,\n                reject\n            });\n            this._startWorker();\n        }));\n    }\n\n    /*\n     * Send a message to a queue.\n     *\n     * This works just like amqplib's `sendToQueue`, except if the channel is not connected, this will wait until the\n     * channel is connected.  Returns a Promise which will only resolve when the message has been succesfully sent.\n     * The returned promise will be rejected only if `close()` is called on this channel before it can be sent.\n     *\n     * `message` here should be a JSON-able object.\n     */\n    sendToQueue(queue, content, options, done=null) {\n        return pb.addCallback(done, new Promise((resolve, reject) => {\n            this._messages.push({\n                type: 'sendToQueue',\n                queue,\n                content,\n                options,\n                resolve,\n                reject\n            });\n            return this._startWorker();\n        }));\n    }\n\n    /**\n     * Create a new ChannelWrapper.\n     *\n     * @param {AmqpConnectionManager} connectionManager - connection manager which\n     *   created this channel.\n     * @param {Object} [options] -\n     * @param {string} [options.name] - A name for this channel.  Handy for debugging.\n     * @param {function} [options.setup] - A default setup function to call.  See\n     *   `addSetup` for details.\n     * @param {boolean} [options.json] - if true, then ChannelWrapper assumes all\n     *   messages passed to `publish()` and `sendToQueue()` are plain JSON objects.\n     *   These will be encoded automatically before being sent.\n     *\n     */\n    constructor(connectionManager, options = {}) {\n        super();\n        this._onConnect = this._onConnect.bind(this);\n        this._onDisconnect = this._onDisconnect.bind(this);\n        this._connectionManager = connectionManager;\n        this.name = options.name;\n\n        this.context = {};\n\n        this._json = ('json' in options) ? options.json : false;\n\n        // Place to store queued messages.\n        this._messages = [];\n\n        // Place to store published, but not yet confirmed messages\n        this._unconfirmedMessages = [];\n\n        // True if the \"worker\" is busy sending messages.  False if we need to\n        // start the worker to get stuff done.\n        this._working = false;\n\n        // If we're in the process of creating a channel, this is a Promise which\n        // will resolve when the channel is set up.  Otherwise, this is `null`.\n        this._settingUp = null;\n\n        // The currently connected channel.  Note that not all setup functions\n        // have been run on this channel until `@_settingUp` is either null or\n        // resolved.\n        this._channel = null;\n\n        // We kill off workers when we disconnect.  Whenever we start a new\n        // worker, we bump up the `_workerNumber` - this makes it so if stale\n        // workers ever do wake up, they'll know to stop working.\n        this._workerNumber = 0;\n\n        // Array of setup functions to call.\n        this._setups = [];\n        if(options.setup) {\n            this._setups.push(options.setup);\n        }\n\n        if(connectionManager.isConnected()) {\n            this._onConnect({\n                connection: this._connectionManager._currentConnection\n            });\n        }\n        connectionManager.on('connect', this._onConnect);\n        connectionManager.on('disconnect', this._onDisconnect);\n    }\n\n    // Called whenever we connect to the broker.\n    _onConnect({ connection }) {\n        this._connection = connection;\n\n        return connection.createConfirmChannel()\n        .then(channel => {\n            this._channel = channel;\n            channel.on('close', () => this._onChannelClose(channel));\n\n            this._settingUp = Promise.all(\n                this._setups.map(setupFn =>\n                    // TODO: Use a timeout here to guard against setupFns that never resolve?\n                    pb.call(setupFn, this, channel)\n                    .catch(err => {\n                        if(this._channel) {\n                            this.emit('error', err, { name: this.name });\n                        } else {\n                            // Don't emit an error if setups failed because the channel was closing.\n                        }\n                    })\n                )\n\n            )\n            .then(() => {\n                this._settingUp = null;\n                return this._channel;\n            });\n\n            return this._settingUp;\n        })\n        .then(() => {\n            if(!this._channel) {\n                // Can happen if channel closes while we're setting up.\n                return;\n            }\n            if (this._unconfirmedMessages.length > 0) {\n                // requeu any messages that were left unconfirmed when connection was lost\n                while (this._unconfirmedMessages.length) {\n                    this._messages.push(this._unconfirmedMessages.shift());\n                }\n            }\n\n            // Since we just connected, publish any queued messages\n            this._startWorker();\n            this.emit('connect');\n        })\n        .catch(err => {\n            this.emit('error', err, { name: this.name });\n            this._settingUp = null;\n            this._channel = null;\n        });\n    }\n\n    // Called whenever the channel closes.\n    _onChannelClose(channel) {\n        if(this._channel === channel) {\n            this._channel = null;\n        }\n    }\n    // Wait for another reconnect to create a new channel.\n\n    // Called whenever we disconnect from the AMQP server.\n    _onDisconnect() {\n        this._channel = null;\n        this._settingUp = null;\n\n        // Kill off the current worker.  We never get any kind of error for messages in flight - see\n        // https://github.com/squaremo/amqp.node/issues/191.\n        this._working = false;\n    }\n\n    // Returns the number of unsent messages queued on this channel.\n    queueLength() {\n        return this._messages.length;\n    }\n\n    // Destroy this channel.\n    //\n    // Any unsent messages will have their associated Promises rejected.\n    //\n    close() {\n        return Promise.resolve()\n        .then(() => {\n            this._working = false;\n            if(this._messages.length !== 0) {\n                // Reject any unsent messages.\n                this._messages.forEach(message => message.reject(new Error('Channel closed')));\n            }\n            if(this._unconfirmedMessages.length !== 0) {\n                // Reject any unconfirmed messages.\n                this._unconfirmedMessages.forEach(message => message.reject(new Error('Channel closed')));\n            }\n\n            this._connectionManager.removeListener('connect', this._onConnect);\n            this._connectionManager.removeListener('disconnect', this._onDisconnect);\n            const answer = (this._channel && this._channel.close()) || undefined;\n            this._channel = null;\n\n            this.emit('close');\n\n            return answer;\n        });\n    }\n\n    _shouldPublish() {\n        return (this._messages.length > 0) && !this._settingUp && this._channel;\n    }\n\n    // Start publishing queued messages, if there isn't already a worker doing this.\n    _startWorker() {\n        if(!this._working && this._shouldPublish()) {\n            this._working = true;\n            this._workerNumber++;\n            this._publishQueuedMessages(this._workerNumber);\n        }\n    }\n\n    _publishQueuedMessages(workerNumber) {\n        if(!this._shouldPublish() || !this._working || (workerNumber !== this._workerNumber)) {\n            // Can't publish anything right now...\n            this._working = false;\n            return Promise.resolve();\n        }\n\n        const channel = this._channel;\n        const message = this._messages.shift();\n        this._unconfirmedMessages.push(message);\n\n        Promise.resolve()\n        .then(() => {\n            const encodedMessage = this._json ? new Buffer.from(JSON.stringify(message.content)) : message.content;\n\n            const sendPromise = (() => {\n                switch (message.type) {\n                    case 'publish':\n                        return new Promise(function(resolve, reject) {\n                            const result = channel.publish(message.exchange, message.routingKey, encodedMessage,\n                                message.options,\n                                err => {\n                                    if(err) {\n                                        reject(err);\n                                    } else {\n                                        setImmediate(() => resolve(result));\n                                    }\n                                });\n                        });\n                    case 'sendToQueue':\n                        return new Promise(function(resolve, reject) {\n                            const result = channel.sendToQueue(message.queue, encodedMessage, message.options, err => {\n                                if(err) {\n                                    reject(err);\n                                } else {\n                                    setImmediate(() => resolve(result));\n                                }\n                            });\n                        });\n\n                    /* istanbul ignore next */\n                    default:\n                        throw new Error(`Unhandled message type ${message.type}`);\n                }\n            })();\n\n            // Send some more!\n            this._publishQueuedMessages(workerNumber);\n\n            return sendPromise;\n        })\n        .then(\n            result => {\n                this._unconfirmedMessages.shift();\n                message.resolve(result);\n            },\n\n            err => {\n                if(!this._channel) {\n                    // Tried to write to a closed channel.  Leave the message in the queue and we'll try again when we\n                    // reconnect.\n                    this._messages.unshift(this._unconfirmedMessages.shift());\n                } else {\n                    // Something went wrong trying to send this message - could be JSON.stringify failed, could be the\n                    // broker rejected the message.  Either way, reject it back\n                    this._unconfirmedMessages.shift();\n                    message.reject(err);\n                }\n            }\n        )\n        .catch( /* istanbul ignore next */ err => {\n            this.emit('error', err);\n            this._working = false;\n        });\n\n        return null;\n    }\n\n    // Send an `ack` to the underlying channel.\n    ack() {\n        return this._channel && this._channel.ack.apply(this._channel, arguments);\n    }\n\n    // Send an `ackAll` to the underlying channel.\n    ackAll() {\n        return this._channel && this._channel.ackAll.apply(this._channel, arguments);\n    }\n\n    // Send a `nack` to the underlying channel.\n    nack() {\n        return this._channel && this._channel.nack.apply(this._channel, arguments);\n    }\n\n    // Send a `nackAll` to the underlying channel.\n    nackAll() {\n        return this._channel && this._channel.nackAll.apply(this._channel, arguments);\n    }\n\n    // Send a `purgeQueue` to the underlying channel.\n    purgeQueue() {\n        return this._channel && this._channel.purgeQueue.apply(this._channel, arguments);\n    }\n\n    // Send a `checkQueue` to the underlying channel.\n    checkQueue() {\n        return this._channel && this._channel.checkQueue.apply(this._channel, arguments);\n    }\n\n    // Send a `assertQueue` to the underlying channel.\n    assertQueue() {\n        return this._channel && this._channel.assertQueue.apply(this._channel, arguments);\n    }\n\n    // Send a `bindQueue` to the underlying channel.\n    bindQueue() {\n        return this._channel && this._channel.bindQueue.apply(this._channel, arguments);\n    }\n\n    // Send a `assertExchange` to the underlying channel.\n    assertExchange() {\n        return this._channel && this._channel.assertExchange.apply(this._channel, arguments);\n    }\n}\n"],"file":"ChannelWrapper.js"}